---
title: 자바스크립트를 사용한 스택 ADT 구현 및 활용(1)
date: '2022-04-06'
lastmod: '2022-04-08'
tags: ['javascript', 'algorithm']
draft: false
summary: 자바스크립트로 스택을 구현하는 과정을 설명합니다.
authors: ['default']
---

# 스택 Stack

## 정의

스택은 리스트와 비슷하면서 보다 다양한 문제를 해결할 수 있는 자료구조다. 리스트는 데이터 저장 순서가 중요하지 않거나, 저장된 데이터를 검색할 필요가 없을때 요긴한 자료구조다.
하지만 단순한 일반 리스트보다 좀 더 복잡한 자료구조가 필요할 때 스택을 사용할 수 있다.

## 특징

스택은 가장 윗부분에서만 자료의 추가와 삭제가 일어난다. 따라서 실행속도가 빠르고 구현이 쉬운 자료구조다. 수식 평가에서부터 메서드 호출까지 다양한 프로그래밍 영역에서 스택이 사용되고 있다.

스택의 특징은 요소 리스트로 구성되며 탑top이라 불리는 리스트의 끝에서만 접근이 가능하다는 것이다.
식당에 쌓아놓은 쟁반에 비유할 수 있는데, 쟁반은 항상 맨 위에 있는 것부터 사용해야 하며
설거지가 끝난 쟁반은 항상 쟁반들의 맨 위에 올려놓아야하는 것과 비슷하다.
따라서 스택은 후입선출(LIFO) 자료구조이다.

이러한 후입선출의 특성 때문에 스택의 맨 윗 요소, 탑에 있지 않은 요소에는 접근이 불가능하다. 만약 스택의 가장 밑바닥의 요소에 접근하려면 그 위의 모든 요소를 제거해야 한다.
스택은 다음 두가지 주요 동작을 제공하게 된다.

- **`push`: 스택에 요소를 추가**
- **`pop`: 스택의 요소를 제거**

위의 두가지 동작 외에 스택의 탑 요소를 확인하는 기능도 제공한다.
`pop`을 사용하여 스택의 탑 요소를 확인하는것도 가능하지만 이는 스택에서 영구적으로 요소를 제거하게 되기때문에 별도의 동작으로 확인하는 방법도 필요할 수 있다.
`peek`을 이용하면 pop과 달리 스택의 탑 요소를 제거하지 않고도 내용을 확인할 수 있다.

- **`peek`: 스택의 탑 요소를 확인**

스택은 탑 요소의 위치와 새로운 요소를 추가할 위치를 `top`이라는 변수를 이용해서 관리한다. 만약 스택에 새 요소를 추가하고 싶으면
top 변수를 증가시키고, 스택에서 요소를 제거하고 싶으면 top 변수를 감소시킨다.
스택은 `push`, `pop`, `peek` 외에도 다양한 기능과 프로퍼티가 있다.

- **`clear`: 스택의 모든 요소를 삭제**
- **`length`: 스택의 요소의 수를 저장**
- **`empty`: 스택에 요소가 있는지 확인**

## 구현

스택을 구현하기 위해서 우선 스택 요소를 내부적으로 저장할 자료구조 중 배열을 사용하기로 한다.
그리고 Stack 클래스를 정의한다.

```javascript
class Stack {
  constructor() {
    this.dataStore = []
    this.top = 0
  }

  push() {}

  pop() {}

  peek() {}

  length() {}

  clear() {}
}
```

`dataStore`는 스택 요소를 저장하는 배열이다.
생성자에서는 빈 배열로 생성한다.
`top`은 스택의 탑 정보이다. 생성자에서 0으로 초기화한다.
스택에 요소를 추가하기 전까지 스택의 탑 위치는 0이다.

이제 메서드들을 구현한다.

### push

`push` 메서드는 아래와 같이 구현한다.

1. 새요소를 스택에 추가할 때 탑 위치에 요소를 저장한다.
2. 그 후 배열에서 빈 공간을 새로운 탑을 가리키도록 top변수를 증가 시킨다.

```javascript
push(element) {
  this.dataStore[this.top++] = element
}
```

특히 this.top 뒤의 연산자(++)를 주목하자.
this.top 뒤에 연산자가 붙음으로 현재 top 위치에 새 요소를 추가한 다음 top이 증가된다(`선할당 후증가`).

### pop

`pop` 메서드는 `push` 메서드와 반대 동작을 한다.

1. 스택의 탑위치에 있는 요소를 반환한다.
2. top변수를 감소시킨다.

```javascript
pop() {
  return this.dataStore[--this.top]
}
```

### peek

`peek` 메서드는 배열의 `top - 1` 위치의 요소에 접근해 스택의 탑 요소를 반환한다.

```javascript
peek() {
  return this.dataStore[this.top - 1]
}
```

스택이 비어 있을 때 `peek`을 호출하면 탑 위치에 값이 없기 떄문에 `undefined`가 반환된다.

### length

`length`를 사용하면 스택에 얼마나 많은 데이터가 저장되어 있는지 확인할 수 있다.

```javascript
length() {
  return this.top
}
```

### clear

마지막으로 `clear`는 `top` 변수를 0으로 설정하여 스택 전체 요소를 삭제한다.

```javascript
clear() {
  this.top = 0
}
```

다음은 Stack 클래스의 구현 코드이다.

```javascript
class Stack {
  constructor() {
    this.dataStore = []
    this.top = 0
  }

  push(element) {
    this.dataStore[this.top++] = element
  }

  pop() {
    return this.dataStore[--this.top]
  }

  peek() {
    return this.dataStore[this.top - 1]
  }

  length() {
    return this.top
  }

  clear() {
    this.top = 0
  }
}
```

다음과 같이 테스트해볼 수 있다.

```javascript
const s = new Stack()
s.push('A')
s.push('B')
console.log(`length: ${s.length()}`) // 2
console.log(s.peek()) // "B"

const popped = s.pop()
console.log(`popped: ${popped}`) // "B"
console.log(s.peek()) // "A"

s.clear()
console.log(`lenth: ${s.length()}`) // 0
console.log(s.peek()) // undeifned
```

## 활용

스택을 이용해 손쉽게 해결할 수 있는 문제 유형을 살펴본다.

### 진법 변환

숫자를 다른 진법으로 변환할 때 스택을 이용할 수 있다.
num이라는 숫자를 base라는 진법으로 변환할 때 다음과 같은 과정을 거친다.

> 이 알고리즘은 2~9진수에서만 동작한다.

1. num의 가장 오른쪽 숫자를 `num % base`로 변환한다. 스택에 이 값을 추가한다.
2. n을 `num / base`으로 치환한다.
3. `num = 0`이면서 나머지가 없을 때까지 위의 과정(1,2)를 반복한다.
4. `num = 0`이면서 나머지가 없으면 스택의 저장된 숫자를 모두 꺼내 변환된 숫자 문자열을 만든다.

```javascript
function mulBase(num, base) {
  const s = new Stack()
  do {
    s.push(num % base)
    num = Math.floor((num /= base))
  } while (num > 0)

  let converted = ''
  while (s.length() > 0) {
    converted += s.pop()
  }
  return converted
}
```

아래와 같이 테스트해볼 수 있다.

```javascript
// 10을 2진법으로 변환
console.log(mulBase(10,2))) // "1010"

// 50을 3진법으로 변환
console.log(mulBase(50,3)) // "1212"

// 32를 9진법으로 변환
console.log(mulBase(32,9)) // "35"
```

### 회문(펠린드롬)

회문은 앞부터 읽었을 때와 뒤부터 읽었을 떄가 같은 단어, 구절, 숫자를 말한다.
예를 들어서 `dad`나 `racecar`는 회문이다.
`1001`이라는 숫자도 회문이다.

어떤 문자열이 회문인지에 대한 여부를 스택을 이용해 판단할 수가 있다.

1. 문자열을 받아 왼쪽에서 오른쪽으로 각 문자를 스택에 추가한다.
2. 문자열을 끝까지 스택에 추가하면 원래 문자열의 마지막 문자은 스택의 탑에 위치한다.
3. 원래 문자열의 첫 문자는 스택의 바텀(bottom)에 위치한다.

스택에 문자열을 모두 추가했으면 스택의 각 문자를 다시 꺼내서 새 문자열을 만들 수 있다.
그러면 원래 문자열을 역순으로 바꾼 문자열이 만들어지는데 이렇게 만들어진 역순 문자열을
원래 문자열과 비교해서 같으면 회문이고 같지않으면 회문이 아니라고 판별할 수 있다.

```javascript
function isPalindrome(word) {
  const s = new Stack()
  for (let i = 0; i < word.length; ++i) {
    s.push(word[i])
  }

  let rword = ''
  while (s.length() > 0) {
    rword += s.pop()
  }

  return word === rword
}
```

다음과 같이 테스트해볼 수 있다.

```javascript
console.log(isPalindrome('hello')) // false
console.log(isPalindrome('racecar')) // true
```

### 재귀

## 참고

`자바스크립트 자료구조와 알고리즘 (마이클 맥일런)`
